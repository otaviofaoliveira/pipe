<html>

<!-- Mirrored from www.ecs.umass.edu/ece/koren/architecture/windlx/help.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 02 Feb 2017 16:37:45 GMT -->
<head>
<title>Manual</title>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<body>
<a href="#OVERVIEW">Visão Geral</a><br>
<a href="#REGISTERS">Registradores</a><br>
<a href="#ASSEMBLY">Instruções</a><br>
<a href="#STRUCTURAL">Unidades Estruturais</a><br>
<a href="#APPLICATION">Usando a Aplicação</a><br>

<p>
<hr>
<a name="OVERVIEW"></a>
<b>Visão Geral</b><br>
  Esta aplicação é uma simulação de um MIPS Five Stage Pipeline. O usuário pode escolher 
  um número limitado de instruções de montagem a serem executadas no pipeline. As instruções
  na tabela são verificadas se existem dependências antes da execução. Durante a execução, as 
  instruções podem ser executadas passo a passo ou simplesmente executada totalmente e exibidos
  instantaneamente. Também o usuário se dispõe da opção Data Forwarding, que pode ser ativada 
  a qualquer instante da execução.
<p>
  A simulação não permite ao usuário inserir valores específicos nos registros e não calcula o 
  resultado real de nenhuma das instruções. Esta é simplesmente uma ferramenta que deve ser 
  usada para detectar possíveis conflitos de dados e estruturais e para ver as instruções como 
  eles são executados em um pipeline MIPS cinco estágios.
<p>
  As instruções são inseridas em ordem, para que os perigos de WAR nunca possam ocorrer enquanto 
  as instruções estão sendo executadas. 
<p>
<hr>
<a name="REGISTERS"></a>
<b>REgistradores</b><br>
  A simulação suporta 16 registradores de ponto flutuante (F0 - F15) e 32 registros de inteiro (R1 - R32).
<p>
<hr>
<a name="ASSEMBLY"></a>
<b>Instruções</b><br>
 São Suportadas as seguintes instruções:
<p>
<b>ADD.D(dest, src1, src2)</b> <br>
  A instrução de adição de ponto flutuante adiciona os dois registos de origem (src1 e src2) e 
  armazena o resultado no registo de destino (dest). Esta instrução pode levar de 1 a 20 ciclos
  para completar a execução. O tempo   de execução é selecionável pelo usuário e é sempre o mesmo 
  que a instrução FP_Sub.
<p>
<b>SUB.D(dest, src1, src2)</b> <br>
  A instrução de subtração de ponto flutuante subtrai os dois registros de origem (src1 e src2) e 
  armazena o resultado no   registrador de destino (dest). Esta instrução pode levar de 1 a 20 
  ciclos para completar a execução. O tempo de execução é selecionável pelo usuário e é sempre o 
  mesmo que a instrução FP_Add.
<p>
<b>MULT.D(dest, src1, src2)</b> <br>
  A instrução de multiplicação de ponto flutuante multiplica os dois registos de origem (src1 e src2) e 
  armazena o resultado no registo de destino (dest). Esta instrução pode levar de 1 a 20 ciclos para completar 
  a execução. O tempo de execução é selecionável pelo usuário.
<p>
<b>DIV.D(dest, src1, src2)</b> <br>
  A instrução de divisão de ponto flutuante divide os dois registos de origem (src1 e src2) e armazena o resultado 
  no registo de destino(dest). Esta instrução pode levar de 1 a 20 ciclos para completar a execução. O tempo de execução é 
  selecionável pelo usuário.
<p>
<b>LD(dest, offset, src1)</b> <br>
  A instrução de LOAD de ponto flutuante usa um valor inteiro armazenado no registro de origem (src1) e um deslocamento (offset)
  para calcular o endereço de memória a partir do qual os dados serão carregados no registrador de destino (dest). Esta instrução 
  leva 1 ciclo durante o estágio de execução para calcular o endereço de memória. O valor da memória está disponível após 
  o estágio MEM. Presume-se que os dados solicitados estão sempre disponíveis no cache de dados para que o pipeline nunca 
  terá de parar enquanto os dados são lidos da memória.
<p>
<b>SD(src1, offset, src2)</b> <br>
  A instrução de STORE de ponto flutuante utiliza um valor inteiro armazenado no registo de origem (src2) 
  e um deslocamento (offset) para calcular o endereço de memória para o qual os dados no registo de origem (src1) serão armazenados.
  Esta instrução leva 1 ciclo durante o estágio de execução para calcular o endereço de memória. O valor é gravado 
  na memória até o final do estágio MEM. Presume-se que os dados a serem gravados na memória já estão disponíveis 
  no cache de dados para que o pipeline nunca terá de parar enquanto os dados são gravados na memória. Esta instrução 
  não passa pelo estágio WB.<p>
<b>ADD(dest, src1, src2)</b> <br>
  A instrução ADD adiciona os dois registos de origem (src1 e src2) e armazena o resultado no registo de destino (dest). Esta 
  instrução leva 1 ciclo para completar a execução.
<p>
<b>SUB(dest, src1, src2)</b> <br>
  A instrução de subtração de inteiros subtrai os dois registos de origem (src1 e src2) e armazena o resultado no 
  registo de destino (dest). Esta instrução leva 1 ciclo para completar a execução.
<p>
<b>MULT(dest, src1, src2)</b> <br>
  A instrução multiplicação inteira multiplica os dois registos de origem (src1 e src2) e armazena o resultado no 
  registo de destino (dest). Esta instrução leva 1 ciclo para completar a execução.
<p>
<b>DIV(dest, src1, src2)</b> <br>
  A instrução de divisão de inteiro divide os dois registros de origem (src1 e src2) e armazena o resultado no 
  registrador de destino (dest). Esta instrução pode levar de 1 a 20 ciclos para completar a execução. O tempo de execução é 
  selecionável pelo usuário.
<p>
<b>LW(dest, offset, src1)</b> <br>
  A instrução de LOAD inteira utiliza um valor inteiro armazenado no registo de origem (src1) e um deslocamento (offset) para 
  calcular o endereço de memória a partir do qual os dados serão carregados para o registo de destino (dest). Esta instrução leva 
  1 ciclo durante o estágio de execução para calcular o endereço de memória. O valor da memória está disponível após
  o estágio MEM. Presume-se que os dados solicitados estão sempre disponíveis no cache de dados para que o pipeline 
  nunca terá de parar enquanto os dados são lidos da memória.

<p>
<b>SW(src1, offset, src2)</b> <br>
  A instrução de STORE de inteiro usa um valor inteiro armazenado no registro de origem (src2) e um deslocamento (offset) 
  para calcular o endereço de memória para o qual os dados no registro de fonte (src1) serão armazenados. Esta instrução 
  leva 1 ciclo durante o estágio de execução para calcular o endereço de memória. O valor é gravado na memória até o 
  final do estágio MEM. Presume-se que os dados a serem gravados na memória já estão disponíveis no cache de dados 
  para que o pipeline nunca terá de parar enquanto os dados são gravados na memória. Esta instrução não passa pelo estágio WB.
<p>
  <b>DADDUI(src1, src2, offset)</b> <br>
  A instrução ADD adiciona um inteiro (offset) imediatamente ao registo de origem (src2) e armazena o resultado no registo de 
  destino (src1).
<p>
  <b>SUBI(src1, src2, offset)</b> <br>
  A instrução de subtração imediata de inteiros subtrai um valor (offset) do registos de origem (src2) e armazena o resultado no 
  registo de destino (src1).
  <p>
<b>BEQ(offset, src1)</b> <br>
  A instrução de ramificação usada usa um valor inteiro armazenado no registro de fonte (src1) e um deslocamento (offset) para 
  calcular o endereço de memória de alvo de ramificação. Esta instrução assume que a condição de ramificação é
  avaliada como "TRUE". Assim, se houver uma instrução imediatamente após esta instrução no pipeline, ela deve
  ser cancelada. Assume-se que o endereço de alvo de ramificação ea avaliação de condição de ramificação podem
  ser determinados pelo final se o estágio de ID. Assim, esta instrução nunca entra no estágio EX.
<p>
<b>BNEZ(offset, src1)</b> <br>
  A instrução untaken de ramo usa um valor inteiro armazenado no registro de origem (src1) e um deslocamento (offset) 
  para calcular o endereço de memória de alvo de ramificação. Esta instrução assume que a condição de ramificação 
  é avaliada como "FALSE". Assim, se houver uma instrução imediatamente após esta instrução no pipeline, ela 
  continuará executando sem problemas. Supõe-se que o endereço de alvo de ramificação e a avaliação de condição 
  de ramificação podem ser determinados pelo final se o estágio de ID. Assim, esta instrução nunca entra no estágio EX.
<p>
<hr>
<a name="STRUCTURAL"></a>
<b>Unidades Estruturais</b><br>
  Esta simulação contém 6 unidades estruturais que podem causar um risco estrutural.<br>
  1. Unidade de adição / subtração de ponto flutuante.<br>
  2. Unidade de Multiplicação de Ponto Flutuante.<br>
  3. Unidade de divisão de ponto flutuante.<br>
  4. Adicionar / subtrair unidade inteira.<br>
  5. Inteiro Multiplique a Unidade.<br>
  6. Divisão Inteira Unidade.<p>
  Nota: As instruções de LOAD e STORE usam a Unidade de adição / subtração de números inteiros para calcular
  o endereço de memória. Portanto, um LOAD de ponto flutuante ou STORE pode ser paralisada por uma adição ou 
  subtração de ponto flutuante que leva mais de um ciclo para concluir.
<p>
<hr>
<a name="APPLICATION"></a>
<b>Usando a Aplicação</b><br>
  A aplicação é dividida em duas partes: a parte superior (Top frame) e a parte inferior (Bottom frame). Inicialmente
  o Bottom frame não exibira nada.
<p>
<b>Parte Superior (Top Frame)</b><br>
  A parte superior permite que o usuário insira e remova instruções do pipeline. Ele também permite que o usuário defina 
  o tempo de execução para várias das instruções e para habilitar ou desabilitar o adiantamento de dados.
<p>
<b>Adicionando uma Instrução</b> <br>
  Para adicionar uma instrução ao pipeline, o usuário primeiro seleciona o nome da instrução que gostaria de adicionar.
  Uma vez seleccionado o nome da instrução, o usuário pode seleccionar os registos que gostaria de associar a esta instrução 
  seguindo o formato de instrução. Quando os registros foram selecionados, o usuário deve clicar no botão "Inserir Instrução".
  Isso fará com que o estado atual do pipeline apareça na parte inferior (Bottom frame). O usuário pode continuar inserindo 
  instruções repetindo este procedimento a qualquer momento.
<p>
<b>Removendo uam Instrução</b> <br>
  No caso de um usuário cometer um erro ao inserir uma instrução no pipeline, a última instrução inserida pode ser removida 
  do pipeline clicando no botão "Remover Instrução".
<p>
<b>Adiantamento dos Dados</b> <br>
  O adiantamento de dados pode ser ativado selecionando a caixa de seleção "Habilitar adiantamento". O adiantamento de dados 
  pode ser desativado clicando novamente na caixa de seleção de "Habilitar adiantamento". Sempre que esse valor é alterado, 
  a parte inferior é atualizada para exibir o novo estado do pipeline.
<p>
<b>Resetando a Aplicação.</b> <br>
  O aplicação pode ser resetada a qualquer momento clicando no botão "Resetar Aplicação".
<p>
<b>Ajuda</b> <br>
  Esta página pode ser acessada a qualquer momento clicando no botão "Ajuda" e irá exibir o manual da aplicação.
<p>
<b>Configurando o Tempo de Execução da Instrução</b> <br>
  Existem 4 unidades funcionais para as quais o tempo de execução pode ser modificado pelo usuário (ADD.D/SUB.D, MULT.D,
  DIV.D, DIV). Para alterar o tempo de execução de uma determinada unidade funcional, selecione a caixa ao lado da função
  e selecione o número de ciclos que a unidade funcional deve tomar para concluir uma operação. Sempre que um tempo de 
  execução é alterado, a parte inferior é atualizada para exibir o novo estado do pipeline.
<p>
<b>Parte Inferior (Bottom Frame)</b><br>
  A parte inferior é dividida em duas seções. A seção superior mostra as instruções no pipeline e em que estágio cada 
  instrução está e como é executada. A seção inferior é usada para listar os potenciais riscos estruturais e de dados.
<p>
<b>Executando passo-a-passo</b><br>
O usuário pode percorrer as instruções na pipeline um ciclo de cada vez clicando no botão "Executar Passo-a-Passo" repetidamente.
<p>
<b>Executando todas Instruções</b><br>
O usuário pode executar todas as instruções clicando no botão "Executar tudo".
<p>


</body>

<!-- Mirrored from www.ecs.umass.edu/ece/koren/architecture/windlx/help.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 02 Feb 2017 16:37:45 GMT -->
</html>
